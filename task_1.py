"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.

Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается

И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""

from random import randint
import timeit

nums = [randint(-9000, 9000) for i in range(3000)]

def func_1(nums):               #O(n^2)
    new_arr = []
    for i in range(len(nums)):  #O(n)
        if nums[i] % 2 == 0:
            new_arr.append(i)   #O(n)
    return new_arr

def optimized_func_1(nums):
    return [i for i in range(len(nums)) if nums[i] % 2 == 0]    #O(n)

print(timeit.timeit('func_1(nums)', globals = globals(), number = 10000))
print(timeit.timeit('optimized_func_1(nums)', globals = globals(), number = 10000))

"""
ВЫВОДЫ:
В исходной функции новый список генерировался при помощи цикла, я оптимизировала её при помощи спискового включения. Так мы снижаем сложность О,
потому что не вызываем метод append() на каждой итерации, и поэтому время выполнения функции становится меньше."""